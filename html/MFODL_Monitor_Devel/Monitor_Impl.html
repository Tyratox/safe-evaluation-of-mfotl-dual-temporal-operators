<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Monitor_Impl</title>
</head>


<body>
<div class="head">
<h1>Theory Monitor_Impl</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Monitor_Impl
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Monitor.html">Monitor</a>
    <a href="Optimized_MTL.html">Optimized_MTL</a>
    <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Nat.html">HOL-Library.Code_Target_Nat</a>"</span>
    <a href="../Containers/Containers.html">Containers.Containers</a>
    <span class="quoted">"<a href="../Generic_Join_Devel/Proj_Code.html">Generic_Join_Devel.Proj_Code</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of the generic algorithm and code setup›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code_unfold</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">code_post</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">≡</span> Cardinality.card'"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">card</span><span class="main">]</span><span class="main">]</span> Set_Impl.card_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">instantiation</span></span> enat <span class="main">::</span> <span class="quoted">set_impl</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">set_impl_enat</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>enat<span class="main">,</span> set_impl<span class="main">)</span> phantom"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">set_impl_enat</span> <span class="main">=</span> phantom set_RBT"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">Formula.trm</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">Formula.trm</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">Formula.trm</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">Monitor.mregex</span>
<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">Monitor.mregex</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">Monitor.mregex</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">Monitor.mregex</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> cenum <span class="quoted">Monitor.mregex</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">string8</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">string8</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">event_data</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> mapping_impl <span class="quoted">event_data</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_new_mmuaux'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data table <span class="main">⇒</span> event_data table <span class="main">⇒</span> ts <span class="main">⇒</span> event_data mmuaux <span class="main">⇒</span>
  event_data mmuaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_new_mmuaux'</span> <span class="main">=</span> add_new_mmuaux"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> muaux <span class="quoted">valid_mmuaux</span> <span class="quoted">init_mmuaux</span> <span class="quoted">add_new_mmuaux'</span> <span class="quoted">length_mmuaux</span> <span class="quoted">eval_mmuaux</span>
  <span class="keyword1"><span class="command">using</span></span> valid_init_mmuaux valid_add_new_mmuaux valid_length_mmuaux valid_eval_mmuaux
  <span class="keyword1"><span class="command">unfolding</span></span> add_new_mmuaux'_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> vmsaux <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'a</span> table<span class="main">)</span> list"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_vmsaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> nat <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span>
  <span class="main">(</span>nat <span class="main">×</span> event_data table<span class="main">)</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid_vmsaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">cur</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">aux</span><span class="main">)</span> <span class="bound">auxlist</span><span class="main">.</span> <span class="bound">t</span> <span class="main">=</span> <span class="bound">cur</span> <span class="main">∧</span> <span class="bound">aux</span> <span class="main">=</span> <span class="bound">auxlist</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">init_vmsaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data vmsaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">init_vmsaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_new_ts_vmsaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> nat <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> event_data vmsaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_new_ts_vmsaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">args</span> <span class="bound">nt</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">nt</span><span class="main">,</span> filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">rel</span><span class="main">)</span><span class="main">.</span>
    memR <span class="main">(</span>args_ivl <span class="bound">args</span><span class="main">)</span> <span class="main">(</span><span class="bound">nt</span> <span class="main">-</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">join_vmsaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data table <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> event_data vmsaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">join_vmsaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">args</span> <span class="bound">rel1</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">rel</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span><span class="bound">t</span><span class="main">,</span> join <span class="bound">rel</span> <span class="main">(</span>args_pos <span class="bound">args</span><span class="main">)</span> <span class="bound">rel1</span><span class="main">)</span><span class="main">)</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_new_table_vmsaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data table <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span>
  event_data vmsaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_new_table_vmsaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">args</span> <span class="bound">rel2</span> <span class="main">(</span><span class="bound">cur</span><span class="main">,</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">cur</span><span class="main">,</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">auxlist</span> <span class="keyword1">of</span>
    <span class="main">[]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="bound">cur</span><span class="main">,</span> <span class="bound">rel2</span><span class="main">)</span><span class="main">]</span>
  <span class="main">|</span> <span class="main">(</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">#</span> <span class="bound">ts</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">t</span> <span class="main">=</span> <span class="bound">cur</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">y</span> <span class="main">∪</span> <span class="bound">rel2</span><span class="main">)</span> <span class="main">#</span> <span class="bound">ts</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">cur</span><span class="main">,</span> <span class="bound">rel2</span><span class="main">)</span> <span class="main">#</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">result_vmsaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> event_data table"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">result_vmsaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">args</span> <span class="main">(</span><span class="bound">cur</span><span class="main">,</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">.</span>
    foldr <span class="main">(∪)</span> <span class="main">[</span><span class="bound">rel</span><span class="main">.</span> <span class="main">(</span>t<span class="main">,</span> rel<span class="main">)</span> <span class="main">←</span> <span class="bound">auxlist</span><span class="main">,</span> memL <span class="main">(</span>args_ivl <span class="bound">args</span><span class="main">)</span> <span class="main">(</span><span class="bound">cur</span> <span class="main">-</span> <span class="bound">t</span><span class="main">)</span><span class="main">]</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> vmuaux <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'a</span> table <span class="main">×</span> <span class="tfree">'a</span> table<span class="main">)</span> list"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_vmuaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> nat <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span>
  <span class="main">(</span>nat <span class="main">×</span> event_data table <span class="main">×</span> event_data table<span class="main">)</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">valid_vmuaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">cur</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">aux</span><span class="main">)</span> <span class="bound">auxlist</span><span class="main">.</span> <span class="bound">t</span> <span class="main">=</span> <span class="bound">cur</span> <span class="main">∧</span> <span class="bound">aux</span> <span class="main">=</span> <span class="bound">auxlist</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">init_vmuaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data vmuaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">init_vmuaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_new_vmuaux</span> <span class="main">::</span>  <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data table <span class="main">⇒</span> event_data table <span class="main">⇒</span> nat <span class="main">⇒</span>
  event_data vmuaux <span class="main">⇒</span> event_data vmuaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_new_vmuaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">args</span> <span class="bound">rel1</span> <span class="bound">rel2</span> <span class="bound">nt</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">nt</span><span class="main">,</span> update_until <span class="bound">args</span> <span class="bound">rel1</span> <span class="bound">rel2</span> <span class="bound">nt</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">length_vmuaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">length_vmuaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">.</span> length <span class="bound">auxlist</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eval_vmuaux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> nat <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span>
  event_data table list <span class="main">×</span> event_data vmuaux"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_vmuaux</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">args</span> <span class="bound">nt</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">auxlist</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">res</span><span class="main">,</span> <span class="bound">auxlist'</span><span class="main">)</span> <span class="main">=</span> eval_until <span class="main">(</span>args_ivl <span class="bound">args</span><span class="main">)</span> <span class="bound">nt</span> <span class="bound">auxlist</span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">res</span><span class="main">,</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">auxlist'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> verimon_maux<span class="main">:</span> maux <span class="quoted">valid_vmsaux</span> <span class="quoted">init_vmsaux</span> <span class="quoted">add_new_ts_vmsaux</span> <span class="quoted">join_vmsaux</span>
  <span class="quoted">add_new_table_vmsaux</span> <span class="quoted">result_vmsaux</span> <span class="quoted">valid_vmuaux</span> <span class="quoted">init_vmuaux</span> <span class="quoted">add_new_vmuaux</span> <span class="quoted">length_vmuaux</span>
  <span class="quoted">eval_vmuaux</span> <span class="quoted">valid_mmtaux</span> <span class="quoted">init_mmtaux</span> <span class="quoted">update_mmtaux</span> <span class="quoted">result_mmtaux</span>
  <span class="keyword2"><span class="keyword">defines</span></span> vminit0 <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.minit0 <span class="main">(</span>init_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux<span class="main">)</span> <span class="main">(</span>init_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux<span class="main">)</span> <span class="main">(</span>init_mmtaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmtaux<span class="main">)</span> <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> Formula.formula <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vminit <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.minit <span class="main">(</span>init_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux<span class="main">)</span> <span class="main">(</span>init_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux<span class="main">)</span> <span class="main">(</span>init_mmtaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmtaux<span class="main">)</span> <span class="main">::</span> Formula.formula <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vminit_safe <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.minit_safe <span class="main">(</span>init_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux<span class="main">)</span> <span class="main">(</span>init_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux<span class="main">)</span> <span class="main">(</span>init_mmtaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmtaux<span class="main">)</span> <span class="main">::</span> Formula.formula <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vmupdate_since <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.update_since add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux <span class="main">(</span>result_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> event_data table<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vmeval <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.meval add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux <span class="main">(</span>result_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_vmuaux <span class="main">(</span>eval_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vmstep <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.mstep add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux <span class="main">(</span>result_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_vmuaux <span class="main">(</span>eval_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vmsteps0_stateless <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.msteps0_stateless add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux <span class="main">(</span>result_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_vmuaux <span class="main">(</span>eval_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vmsteps_stateless <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.msteps_stateless add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux <span class="main">(</span>result_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_vmuaux <span class="main">(</span>eval_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> vmonitor <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.monitor init_vmsaux add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux <span class="main">(</span>result_vmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> init_vmuaux add_new_vmuaux <span class="main">(</span>eval_vmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data vmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> init_mmtaux update_mmtaux result_mmtaux"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> valid_vmsaux_def init_vmsaux_def add_new_ts_vmsaux_def join_vmsaux_def
    add_new_table_vmsaux_def result_vmsaux_def valid_vmuaux_def init_vmuaux_def add_new_vmuaux_def
    length_vmuaux_def eval_vmuaux_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">global_interpretation</span></span> default_maux<span class="main">:</span> maux <span class="quoted">valid_mmsaux</span> <span class="quoted"><span class="quoted">"init_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux"</span></span> <span class="quoted">add_new_ts_mmsaux</span> <span class="quoted">gc_join_mmsaux</span> <span class="quoted">add_new_table_mmsaux</span> <span class="quoted">result_mmsaux</span>
  <span class="quoted">valid_mmuaux</span> <span class="quoted"><span class="quoted">"init_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux"</span></span> <span class="quoted">add_new_mmuaux'</span> <span class="quoted">length_mmuaux</span> <span class="quoted">eval_mmuaux</span> <span class="quoted">valid_mmtaux</span> <span class="quoted">init_mmtaux</span> <span class="quoted">update_mmtaux</span> <span class="quoted">result_mmtaux</span>
  <span class="keyword2"><span class="keyword">defines</span></span> minit0 <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.minit0 <span class="main">(</span>init_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux<span class="main">)</span> <span class="main">(</span>init_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux<span class="main">)</span> <span class="main">(</span>init_mmtaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmtaux<span class="main">)</span> <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> Formula.formula <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> minit <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.minit <span class="main">(</span>init_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux<span class="main">)</span> <span class="main">(</span>init_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux<span class="main">)</span> <span class="main">(</span>init_mmtaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmtaux<span class="main">)</span> <span class="main">::</span> Formula.formula <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> minit_safe <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.minit_safe <span class="main">(</span>init_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux<span class="main">)</span> <span class="main">(</span>init_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux<span class="main">)</span> <span class="main">(</span>init_mmtaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmtaux<span class="main">)</span> <span class="main">::</span> Formula.formula <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> mupdate_since <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.update_since add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux <span class="main">(</span>result_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux <span class="main">⇒</span> event_data table<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> meval <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.meval add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux <span class="main">(</span>result_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_mmuaux' <span class="main">(</span>eval_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> mstep <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.mstep add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux <span class="main">(</span>result_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_mmuaux' <span class="main">(</span>eval_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> msteps0_stateless <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.msteps0_stateless add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux <span class="main">(</span>result_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_mmuaux' <span class="main">(</span>eval_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> msteps_stateless <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.msteps_stateless add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux <span class="main">(</span>result_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> add_new_mmuaux' <span class="main">(</span>eval_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> update_mmtaux result_mmtaux"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> monitor <span class="main">=</span> <span class="quoted"><span class="quoted">"maux.monitor init_mmsaux add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux <span class="main">(</span>result_mmsaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmsaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> init_mmuaux add_new_mmuaux' <span class="main">(</span>eval_mmuaux <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data mmuaux <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> init_mmtaux update_mmtaux result_mmtaux"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">lemma</span></span> image_these<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> Option.these <span class="free">X</span> <span class="main">=</span> Option.these <span class="main">(</span>map_option <span class="free">f</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_these_eq Bex_def image_iff map_option_case <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> default_maux.meval.simps<span class="main">(</span>2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> meval_MPred<span class="main">:</span> <span class="quoted"><span class="quoted">"meval <span class="free">n</span> <span class="free">ts</span> <span class="free">db</span> <span class="main">(</span>MPred <span class="free">e</span> <span class="free">tms</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> Mapping.lookup <span class="free">db</span> <span class="free">e</span> <span class="keyword1">of</span> None <span class="main">⇒</span> replicate <span class="main">(</span>length <span class="free">ts</span><span class="main">)</span> <span class="main">{}</span> <span class="main">|</span> Some <span class="bound">Xs</span> <span class="main">⇒</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">X</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">v</span> <span class="main">∈</span> <span class="bound">X</span><span class="main">.</span>
  <span class="main">(</span>set_option <span class="main">(</span>map_option <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> Table.tabulate <span class="bound">f</span> <span class="main">0</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>match <span class="free">tms</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="bound">Xs</span><span class="main">,</span> MPred <span class="free">e</span> <span class="free">tms</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Option.these_def image_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> meval_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> default_maux.meval.simps<span class="main">(</span>1<span class="main">)</span> meval_MPred default_maux.meval.simps<span class="main">(</span>3-<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mk_db</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Formula.name <span class="main">×</span> event_data list set<span class="main">)</span> list <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mk_db</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Monitor.mk_db <span class="main">(</span><span class="main">⋃</span><span class="bound">n</span> <span class="main">∈</span> set <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> the <span class="main">(</span>map_of <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rbt_fold</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> event_data tuple set_rbt <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_fold</span> <span class="main">=</span> RBT_Set2.fold"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rbt_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"event_data list set_rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_empty</span> <span class="main">=</span> RBT_Set2.empty"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rbt_insert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> event_data list set_rbt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rbt_insert</span> <span class="main">=</span> RBT_Set2.insert"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> saturate_commute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">r</span> <span class="main">∈</span> <span class="free">g</span> <span class="bound">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span>insert <span class="free">r</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">r</span> <span class="main">∈</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">h</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> terminates<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">X</span><span class="main">.</span> <span class="bound">X</span> <span class="main">⊆</span> <span class="free">C</span> <span class="main">⟹</span> <span class="free">g</span> <span class="bound">X</span> <span class="main">⊆</span> <span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"saturate <span class="free">g</span> <span class="main">{}</span> <span class="main">=</span> saturate <span class="free">h</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> saturate_code<span class="main"><span class="keyword3">;</span></span> <span class="operator">subst</span> saturate_code<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> saturate_def while_def
    <span class="keyword1"><span class="command">using</span></span> while_option_finite_subset_Some<span class="main">[</span><span class="operator">OF</span> terminates<span class="main">]</span> assms<span class="main">(</span>1-3<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> while_option_commute_invariant<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∨</span> <span class="free">r</span> <span class="main">∈</span> <span class="bound">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="free">g</span> <span class="bound">S</span> <span class="main">≠</span> <span class="bound">S</span>"</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="free">h</span> <span class="bound">S</span> <span class="main">≠</span> <span class="bound">S</span>"</span></span> <span class="quoted"><span class="quoted">"insert <span class="free">r</span>"</span></span> <span class="quoted"><span class="free">h</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> while_option_stop<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="free">g</span> <span class="bound">S</span> <span class="main">≠</span> <span class="bound">S</span>"</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">RPDs_aux</span> <span class="main">=</span> saturate <span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">∪</span> <span class="main">⋃</span> <span class="main">(</span>RPD <span class="main">`</span> <span class="bound">S</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> RPDs_aux_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"RPDs_aux <span class="free">S</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">S'</span> <span class="main">=</span> <span class="free">S</span> <span class="main">∪</span> Set.bind <span class="free">S</span> RPD <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">S'</span> <span class="main">⊆</span> <span class="free">S</span> <span class="keyword1">then</span> <span class="free">S</span> <span class="keyword1">else</span> RPDs_aux <span class="bound">S'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> RPDs_aux_def bind_UNION
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> saturate_code<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> RPDs_code<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> RPDs_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RPDs <span class="free">r</span> <span class="main">=</span> RPDs_aux <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> RPDs_aux_def RPDs_code
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> saturate_commute<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> C<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"RPDs <span class="free">r</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> 0 3 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mono_def subset_singleton_iff RPDs_refl RPDs_trans finite_RPDs<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">LPDs_aux</span> <span class="main">=</span> saturate <span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">∪</span> <span class="main">⋃</span> <span class="main">(</span>LPD <span class="main">`</span> <span class="bound">S</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> LPDs_aux_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"LPDs_aux <span class="free">S</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">S'</span> <span class="main">=</span> <span class="free">S</span> <span class="main">∪</span> Set.bind <span class="free">S</span> LPD <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">S'</span> <span class="main">⊆</span> <span class="free">S</span> <span class="keyword1">then</span> <span class="free">S</span> <span class="keyword1">else</span> LPDs_aux <span class="bound">S'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> LPDs_aux_def bind_UNION
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> saturate_code<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> LPDs_code<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemma</span></span> LPDs_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"LPDs <span class="free">r</span> <span class="main">=</span> LPDs_aux <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> LPDs_aux_def LPDs_code
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> saturate_commute<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> C<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"LPDs <span class="free">r</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> 0 3 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mono_def subset_singleton_iff LPDs_refl LPDs_trans finite_LPDs<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> is_empty_table_unfold <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> empty_table <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"empty_table <span class="main">=</span> <span class="free">X</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"Cardinality.eq_set <span class="free">X</span> empty_table <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"Cardinality.eq_set empty_table <span class="free">X</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_eq <span class="free">X</span> empty_table <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_eq empty_table <span class="free">X</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> <span class="main">(</span>set_empty <span class="free">impl</span><span class="main">)</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>set_empty <span class="free">impl</span><span class="main">)</span> <span class="main">=</span> <span class="free">X</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"Cardinality.eq_set <span class="free">X</span> <span class="main">(</span>set_empty <span class="free">impl</span><span class="main">)</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"Cardinality.eq_set <span class="main">(</span>set_empty <span class="free">impl</span><span class="main">)</span> <span class="free">X</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_eq <span class="free">X</span> <span class="main">(</span>set_empty <span class="free">impl</span><span class="main">)</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="quoted"><span class="quoted">"set_eq <span class="main">(</span>set_empty <span class="free">impl</span><span class="main">)</span> <span class="free">X</span> <span class="main">⟷</span> Set.is_empty <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> set_eq_def set_empty_def empty_table_def Set.is_empty_def Cardinality.eq_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> tabulate_rbt_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Monitor.mrtabulate <span class="main">(</span><span class="free">xs</span> <span class="main">::</span> mregex list<span class="main">)</span> <span class="free">f</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span>mregex<span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''mrtabulate RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Monitor.mrtabulate <span class="main">(</span><span class="free">xs</span> <span class="main">::</span> mregex list<span class="main">)</span> <span class="free">f</span><span class="main">)</span>
  <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Mapping <span class="main">(</span>RBT_Mapping2.bulkload <span class="main">(</span>List.map_filter <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">fk</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">k</span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">fk</span> <span class="main">=</span> empty_table <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">fk</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mrtabulate.abs_eq RBT_Mapping_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> combine_Mapping<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> ccompare<span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping_rbt"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"Mapping.combine <span class="free">f</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">(</span>RBT_Mapping <span class="free">u</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> ID <span class="keyword1">CCOMPARE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''combine RBT_Mapping: ccompare = None''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Mapping.combine <span class="free">f</span> <span class="main">(</span>RBT_Mapping <span class="free">t</span><span class="main">)</span> <span class="main">(</span>RBT_Mapping <span class="free">u</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> RBT_Mapping <span class="main">(</span>RBT_Mapping2.join <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">f</span><span class="main">)</span> <span class="free">t</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Mapping.combine.abs_eq Mapping_inject lookup_join <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"upd_set <span class="free">m</span> <span class="free">f</span> <span class="main">{}</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"upd_set <span class="free">m</span> <span class="free">f</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Mapping.update <span class="free">x</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>upd_set <span class="free">m</span> <span class="free">f</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Mapping_lookup_upd_set Mapping.lookup_update'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set_fold<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"upd_set <span class="free">m</span> <span class="free">f</span> <span class="free">A</span> <span class="main">=</span> Finite_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> Mapping.update <span class="bound">a</span> <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="free">m</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span><span class="main">.</span> Mapping.update <span class="bound">a</span> <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite.induct<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> upd_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping<span class="main">)</span> comp_fun_idem"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span> <span class="bound">a</span> <span class="bound">m</span><span class="main">.</span> Mapping.update <span class="bound">a</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">a</span><span class="main">)</span> <span class="bound">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"upd_set <span class="free">m</span> <span class="free">f</span> <span class="free">A</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> set_fold_cfi <span class="main">(</span>upd_cfi <span class="free">f</span><span class="main">)</span> <span class="free">m</span> <span class="free">A</span> <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''upd_set: infinite''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> upd_set <span class="free">m</span> <span class="free">f</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upd_set_fold<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lexordp_eq_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lexordp_eq <span class="free">xs</span> <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> True
  <span class="main">|</span> <span class="bound">x</span> <span class="main">#</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">ys</span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> False
    <span class="main">|</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="keyword1">then</span> True <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">&gt;</span> <span class="bound">y</span> <span class="keyword1">then</span> False <span class="keyword1">else</span> lexordp_eq <span class="bound">xs</span> <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> lexordp_eq.simps<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">filter_mapping</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Mapping.filter <span class="main">(</span>filter_cond <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_mapping_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter_mapping <span class="free">m</span> <span class="main">{}</span> <span class="free">t</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_mapping_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_mapping_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter_mapping <span class="free">m</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">m'</span> <span class="main">=</span> filter_mapping <span class="free">m</span> <span class="free">A</span> <span class="free">t</span> <span class="keyword1">in</span>
  <span class="keyword1">case</span> Mapping.lookup <span class="bound">m'</span> <span class="free">x</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> Mapping.delete <span class="free">x</span> <span class="bound">m'</span> <span class="keyword1">else</span> <span class="bound">m'</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">m'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_mapping_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff Let_def Map_To_Mapping.map_apply_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_mapping_fold<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"filter_mapping <span class="free">m</span> <span class="free">A</span> <span class="free">t</span> <span class="main">=</span> Finite_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">m</span><span class="main">.</span>
    <span class="keyword1">case</span> Mapping.lookup <span class="bound">m</span> <span class="bound">a</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> Mapping.delete <span class="bound">a</span> <span class="bound">m</span> <span class="keyword1">else</span> <span class="bound">m</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">m</span><span class="main">)</span> <span class="free">m</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="bound">m</span><span class="main">.</span>
    <span class="keyword1">case</span> Mapping.lookup <span class="bound">m</span> <span class="bound">a</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> Mapping.delete <span class="bound">a</span> <span class="bound">m</span> <span class="keyword1">else</span> <span class="bound">m</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">m</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
      <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff Map_To_Mapping.map_apply_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> filter_mapping_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping<span class="main">)</span> comp_fun_idem"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span> <span class="bound">a</span> <span class="bound">m</span><span class="main">.</span>
    <span class="keyword1">case</span> Mapping.lookup <span class="bound">m</span> <span class="bound">a</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> Mapping.delete <span class="bound">a</span> <span class="bound">m</span> <span class="keyword1">else</span> <span class="bound">m</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
    <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff Map_To_Mapping.map_apply_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_mapping_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"filter_mapping <span class="free">m</span> <span class="free">A</span> <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> set_fold_cfi <span class="main">(</span>filter_mapping_cfi <span class="free">t</span><span class="main">)</span> <span class="free">m</span> <span class="free">A</span> <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''filter_mapping: infinite''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> filter_mapping <span class="free">m</span> <span class="free">A</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_mapping_fold<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">filter_set</span> <span class="free"><span class="bound"><span class="entity">Z</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">as</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">.</span> filter_cond' <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="bound">as</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_set_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter_set <span class="free">Z</span> <span class="free">m</span> <span class="main">{}</span> <span class="free">t</span> <span class="main">=</span> <span class="free">Z</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_set_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter_set <span class="free">Z</span> <span class="free">m</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">Z'</span> <span class="main">=</span> filter_set <span class="free">Z</span> <span class="free">m</span> <span class="free">A</span> <span class="free">t</span> <span class="keyword1">in</span>
  <span class="keyword1">case</span> Mapping.lookup <span class="free">m</span> <span class="free">x</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> <span class="bound">Z'</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="keyword1">else</span> <span class="bound">Z'</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">Z'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def Map_To_Mapping.map_apply_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_set_fold<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"filter_set <span class="free">Z</span> <span class="free">m</span> <span class="free">A</span> <span class="free">t</span> <span class="main">=</span> Finite_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">Z'</span><span class="main">.</span>
    <span class="keyword1">case</span> Mapping.lookup <span class="free">m</span> <span class="bound">a</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> <span class="bound">Z'</span> <span class="main">-</span> <span class="main">{</span><span class="bound">a</span><span class="main">}</span> <span class="keyword1">else</span> <span class="bound">Z'</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">Z'</span><span class="main">)</span> <span class="free">Z</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="bound">Z'</span><span class="main">.</span>
    <span class="keyword1">case</span> Mapping.lookup <span class="free">m</span> <span class="bound">a</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> <span class="bound">Z'</span> <span class="main">-</span> <span class="main">{</span><span class="bound">a</span><span class="main">}</span> <span class="keyword1">else</span> <span class="bound">Z'</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">Z'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
      <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff Map_To_Mapping.map_apply_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Z</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> filter_set_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> set<span class="main">)</span> comp_fun_idem"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">m</span> <span class="bound">t</span> <span class="bound">a</span> <span class="bound">Z'</span><span class="main">.</span>
    <span class="keyword1">case</span> Mapping.lookup <span class="bound">m</span> <span class="bound">a</span> <span class="keyword1">of</span> Some <span class="bound">u</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">t</span> <span class="main">=</span> <span class="bound">u</span> <span class="keyword1">then</span> <span class="bound">Z'</span> <span class="main">-</span> <span class="main">{</span><span class="bound">a</span><span class="main">}</span> <span class="keyword1">else</span> <span class="bound">Z'</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="bound">Z'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_set_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"filter_set <span class="free">Z</span> <span class="free">m</span> <span class="free">A</span> <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">A</span> <span class="keyword1">then</span> set_fold_cfi <span class="main">(</span>filter_set_cfi <span class="free">m</span> <span class="free">t</span><span class="main">)</span> <span class="free">Z</span> <span class="free">A</span> <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''filter_set: infinite''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> filter_set <span class="free">Z</span> <span class="free">m</span> <span class="free">A</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_set_fold<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">shift_end</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> shift_end.simps<span class="main">[</span><span class="operator">folded</span> filter_mapping_def filter_set_def<span class="main">,</span> <span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set'_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"upd_set' <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">{}</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upd_set'_lookup<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set'_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">f</span> <span class="free">d</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> upd_set' <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">let</span> <span class="bound">m'</span> <span class="main">=</span> <span class="main">(</span>upd_set' <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="free">A</span><span class="main">)</span> <span class="keyword1">in</span> <span class="keyword1">case</span> Mapping.lookup <span class="bound">m'</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Mapping.update <span class="free">x</span> <span class="free">d</span> <span class="bound">m'</span>
  <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> Mapping.update <span class="free">x</span> <span class="main">(</span><span class="free">f</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">m'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upd_set'_lookup Mapping.lookup_update' <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set'_aux1<span class="main">:</span> <span class="quoted"><span class="quoted">"upd_set' Mapping.empty <span class="free">d</span> <span class="free">f</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">k</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span> <span class="main">=</span>
  Mapping.update <span class="free">k</span> <span class="free">d</span> <span class="main">(</span>upd_set' Mapping.empty <span class="free">d</span> <span class="free">f</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def upd_set'_lookup Mapping.lookup_update'
      Mapping.lookup_empty <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set'_aux2<span class="main">:</span> <span class="quoted"><span class="quoted">"Mapping.lookup <span class="free">m</span> <span class="free">k</span> <span class="main">=</span> None <span class="main">⟹</span> upd_set' <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">k</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span> <span class="main">=</span>
  Mapping.update <span class="free">k</span> <span class="free">d</span> <span class="main">(</span>upd_set' <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upd_set'_lookup Mapping.lookup_update' <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set'_aux3<span class="main">:</span> <span class="quoted"><span class="quoted">"Mapping.lookup <span class="free">m</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span> <span class="main">⟹</span> upd_set' <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">k</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span> <span class="main">=</span>
  Mapping.update <span class="free">k</span> <span class="main">(</span><span class="free">f</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>upd_set' <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upd_set'_lookup Mapping.lookup_update' <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_set'_aux4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∉</span> fst <span class="main">`</span> <span class="free">A</span> <span class="main">⟹</span> upd_set' Mapping.empty <span class="free">d</span> <span class="free">f</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span> <span class="main">=</span> Mapping.empty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upd_set'_lookup Mapping.lookup_update' Domain.DomainI fst_eq_Domain
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_nested_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"upd_nested <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">{}</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mapping_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upd_nested_lookup <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upd_nested_step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> mapping<span class="main">)</span> mapping <span class="main">⇒</span>
  <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span> mapping<span class="main">)</span> mapping"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">upd_nested_step</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">k'</span><span class="main">)</span> <span class="main">⇒</span>
    <span class="main">(</span><span class="keyword1">case</span> Mapping.lookup <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">k</span> <span class="keyword1">of</span> Some <span class="bound">m'</span> <span class="main">⇒</span>
      <span class="main">(</span><span class="keyword1">case</span> Mapping.lookup <span class="bound">m'</span> <span class="bound">k'</span> <span class="keyword1">of</span> Some <span class="bound">v</span> <span class="main">⇒</span> Mapping.update <span class="bound">k</span> <span class="main">(</span>Mapping.update <span class="bound">k'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">v</span><span class="main">)</span> <span class="bound">m'</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>
      <span class="main">|</span> None <span class="main">⇒</span> Mapping.update <span class="bound">k</span> <span class="main">(</span>Mapping.update <span class="bound">k'</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="bound">m'</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> Mapping.update <span class="bound">k</span> <span class="main">(</span>Mapping.update <span class="bound">k'</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> Mapping.empty<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> upd_nested_insert<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">f</span> <span class="free">d</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> upd_nested <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span>
  upd_nested_step <span class="free">d</span> <span class="free">f</span> <span class="free">x</span> <span class="main">(</span>upd_nested <span class="free">m</span> <span class="free">d</span> <span class="free">f</span> <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> upd_nested_step_def
  <span class="keyword1"><span class="command">using</span></span> upd_set'_aux1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> upd_set'_aux2<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">_</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span> upd_set'_aux3<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="free">f</span></span> <span class="main">_</span> <span class="quoted"><span class="free">A</span></span><span class="main">]</span>
    upd_set'_aux4<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def upd_nested_lookup upd_set'_lookup Mapping.lookup_update'
      Mapping.lookup_empty <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits prod.splits if_splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mapping_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upd_nested_max_tstp</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">upd_nested_max_tstp</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> upd_nested <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">(</span>max_tstp <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> upd_nested_max_tstp_fold<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"upd_nested_max_tstp <span class="free">m</span> <span class="free">d</span> <span class="free">X</span> <span class="main">=</span> Finite_Set.fold <span class="main">(</span>upd_nested_step <span class="free">d</span> <span class="main">(</span>max_tstp <span class="free">d</span><span class="main">)</span><span class="main">)</span> <span class="free">m</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"upd_nested_step <span class="free">d</span> <span class="main">(</span>max_tstp <span class="free">d</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> ext<span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def upd_nested_step_def Mapping.lookup_update' Mapping.lookup_empty
       update_update max_tstp_d_d max_tstp_idem' <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> upd_nested_insert' <span class="main">=</span> upd_nested_insert<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="quoted">"max_tstp <span class="free">d</span>"</span></span><span class="main">,</span>
    <span class="operator">OF</span> max_tstp_d_d<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> max_tstp_idem'<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">X</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite.induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upd_nested_max_tstp_def upd_nested_insert'<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> upd_nested_max_tstp_cfi <span class="main">::</span>
  <span class="quoted"><span class="quoted">"ts <span class="main">+</span> tp <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> ts <span class="main">+</span> tp<span class="main">)</span> mapping<span class="main">)</span> mapping<span class="main">)</span> comp_fun_idem"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">d</span><span class="main">.</span> upd_nested_step <span class="bound">d</span> <span class="main">(</span>max_tstp <span class="bound">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> ext<span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def upd_nested_step_def Mapping.lookup_update' Mapping.lookup_empty
      update_update max_tstp_d_d max_tstp_idem' <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_nested_max_tstp_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"upd_nested_max_tstp <span class="free">m</span> <span class="free">d</span> <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">X</span> <span class="keyword1">then</span> set_fold_cfi <span class="main">(</span>upd_nested_max_tstp_cfi <span class="free">d</span><span class="main">)</span> <span class="free">m</span> <span class="free">X</span>
    <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''upd_nested_max_tstp: infinite''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> upd_nested_max_tstp <span class="free">m</span> <span class="free">d</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upd_nested_max_tstp_fold<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">add_new_mmuaux'</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> add_new_mmuaux'_def<span class="main">[</span><span class="operator">unfolded</span> add_new_mmuaux.simps<span class="main">,</span> <span class="operator">folded</span> upd_nested_max_tstp_def<span class="main">,</span> <span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">filter_join</span> <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> Mapping.filter <span class="main">(</span>join_filter_cond <span class="free"><span class="bound"><span class="entity">pos</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_join_False_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"filter_join False <span class="main">{}</span> <span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_join_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_join_False_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"filter_join False <span class="main">(</span>insert <span class="free">a</span> <span class="free">A</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span>
  filter_join False <span class="free">A</span> <span class="main">(</span>Mapping.delete <span class="free">a</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Mapping.lookup <span class="main">(</span>filter_join False <span class="main">(</span>insert <span class="free">a</span> <span class="free">A</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span>
      Mapping.lookup <span class="main">(</span>filter_join False <span class="free">A</span> <span class="main">(</span>Mapping.delete <span class="free">a</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_join_def Mapping.lookup_filter Mapping_lookup_delete
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mapping_eqI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_join_False<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"filter_join False <span class="free">A</span> <span class="free">m</span> <span class="main">=</span> Finite_Set.fold Mapping.delete <span class="free">m</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"Mapping.delete"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite.induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_join_False_empty filter_join_False_insert fold_fun_left_comm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> filter_not_in_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> mapping<span class="main">)</span> comp_fun_idem"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Mapping.delete"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_join_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"filter_join <span class="free">pos</span> <span class="free">A</span> <span class="free">m</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span><span class="free">pos</span> <span class="main">∧</span> finite <span class="free">A</span> <span class="main">∧</span> card <span class="free">A</span> <span class="main">&lt;</span> Mapping.size <span class="free">m</span> <span class="keyword1">then</span> set_fold_cfi filter_not_in_cfi <span class="free">m</span> <span class="free">A</span>
    <span class="keyword1">else</span> Mapping.filter <span class="main">(</span>join_filter_cond <span class="free">pos</span> <span class="free">A</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_join_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">use</span> filter_join_False <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> filter_join_def›</span><span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">join_mmsaux</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> join_mmsaux.simps<span class="main">[</span><span class="operator">folded</span> filter_join_def<span class="main">,</span> <span class="operator">code</span><span class="main">]</span>

<span class="comment1">(*
definition set_minus :: "'a set ⇒ 'a set ⇒ 'a set" where
  "set_minus X Y = X - Y"

lift_definition remove_cfi :: "('a, 'a set) comp_fun_idem"
  is "λb a. a - {b}"
  by unfold_locales auto

lemma set_minus_finite:
  assumes fin: "finite Y"
  shows "set_minus X Y = Finite_Set.fold (λa X. X - {a}) X Y"
proof -
  interpret comp_fun_idem "λa X. X - {a}"
    by unfold_locales auto
  from assms show ?thesis
    by (induction Y arbitrary: X rule: finite.induct) (auto simp add: set_minus_def)
qed

lemma set_minus_code[code]: "set_minus X Y =
  (if finite Y ∧ card Y &lt; card X then set_fold_cfi remove_cfi X Y else X - Y)"
  by transfer (use set_minus_finite in ‹auto simp add: set_minus_def›)

declare [[code drop: bin_join]]
declare bin_join.simps[folded set_minus_def, code]
*)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">remove_Union</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">remove_Union</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">-</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> remove_Union_finite<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"remove_Union <span class="free">A</span> <span class="free">X</span> <span class="free">B</span> <span class="main">=</span> Finite_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">-</span> <span class="free">B</span> <span class="bound">x</span><span class="main">)</span> <span class="free">A</span> <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> comp_fun_idem <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">-</span> <span class="free">B</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">X</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> remove_Union_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> remove_Union_cfi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span> set<span class="main">)</span> comp_fun_idem"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">B</span> <span class="bound">x</span> <span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">-</span> <span class="bound">B</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> remove_Union_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"remove_Union <span class="free">A</span> <span class="free">X</span> <span class="free">B</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> finite <span class="free">X</span> <span class="keyword1">then</span> set_fold_cfi <span class="main">(</span>remove_Union_cfi <span class="free">B</span><span class="main">)</span> <span class="free">A</span> <span class="free">X</span> <span class="keyword1">else</span> <span class="free">A</span> <span class="main">-</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">B</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">X</span></span> <span class="quoted"><span class="free">B</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">use</span> remove_Union_finite<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">X</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="main">]</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> remove_Union_def›</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> tabulate_remdups<span class="main">:</span> <span class="quoted"><span class="quoted">"Mapping.tabulate <span class="free">xs</span> <span class="free">f</span> <span class="main">=</span> Mapping.tabulate <span class="main">(</span>remdups <span class="free">xs</span><span class="main">)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_of_map_restrict<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> clearjunk <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>string8 <span class="main">×</span> event_data list set<span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span>string8<span class="main">,</span> event_data list set list<span class="main">)</span> alist"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">t</span><span class="main">.</span> List.map_filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">X</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">X</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="main">[</span><span class="bound">X</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>AList.clearjunk <span class="bound">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_filter_def o_def list.map_comp
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted">fst</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_filter_def distinct_map_fst_filter <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_filter_snd_map_filter<span class="main">:</span> <span class="quoted"><span class="quoted">"List.map_filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">P</span> <span class="bound">b</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span>
    map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_filter_def prod.case_eq_if<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_db_code_alist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mk_db <span class="free">t</span> <span class="main">=</span> Assoc_List_Mapping <span class="main">(</span>clearjunk <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mk_db_def Assoc_List_Mapping_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer'</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_filter_snd_map_filter fun_eq_iff map_of_map image_iff map_of_clearjunk
      map_of_filter_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> weak_map_of_SomeI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> map_of_SomeD<span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mk_db_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mk_db <span class="free">t</span> <span class="main">=</span> Mapping.of_alist <span class="main">(</span>List.map_filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">X</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">X</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="main">[</span><span class="bound">X</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>AList.clearjunk <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mk_db_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer'</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_filter_snd_map_filter fun_eq_iff map_of_map image_iff
      map_of_clearjunk map_of_filter_apply <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> weak_map_of_SomeI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> map_of_SomeD<span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">New_max_getIJ_genericJoin</span> <span class="quoted">New_max_getIJ_wrapperGenericJoin</span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> New_max.genericJoin_code<span class="main">[</span><span class="operator">folded</span> remove_Union_def<span class="main">,</span> <span class="operator">code</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> New_max.wrapperGenericJoin.simps<span class="main">[</span><span class="operator">folded</span> remove_Union_def<span class="main">,</span> <span class="operator">code</span><span class="main">]</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</body>

</html>