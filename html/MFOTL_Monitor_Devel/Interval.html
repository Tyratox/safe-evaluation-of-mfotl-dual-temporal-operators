<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Interval</title>
</head>


<body>
<div class="head">
<h1>Theory Interval</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Interval
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Library/Extended_Nat.html">HOL-Library.Extended_Nat</a>"</span> <span class="quoted">"<a href="../../HOL/HOL-Library/Product_Lexorder.html">HOL-Library.Product_Lexorder</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Intervals›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upclosed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">upclosed</span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">l</span> <span class="bound">m</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="bound">l</span> <span class="main">⟶</span> <span class="bound">l</span> <span class="main">≤</span> <span class="bound">m</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downclosed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">downclosed</span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span> <span class="bound">r</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="bound">r</span> <span class="main">⟶</span> <span class="bound">m</span> <span class="main">≤</span> <span class="bound">r</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">mem</span></span></span> <span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">typedef</span></span> ℐ <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">memL</span><span class="main">,</span> <span class="bound">memR</span><span class="main">,</span> <span class="bound">bounded</span><span class="main">)</span><span class="main">.</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">m</span><span class="main">.</span> <span class="bound">memL</span> <span class="bound">m</span> <span class="main">∧</span> <span class="bound">memR</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∧</span> upclosed <span class="bound">memL</span> <span class="main">∧</span> downclosed <span class="bound">memR</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">bounded</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">memR</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">(</span></span></span><span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> True<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">λ</span></span></span><span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> True<span class="main"><span class="main"><span class="main">,</span></span></span> False<span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upclosed_def downclosed_def<span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_ℐ

<span class="keyword1"><span class="command">lift_definition</span></span> memL <span class="main">::</span> <span class="quoted"><span class="quoted">"ℐ <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">fst</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> memR <span class="main">::</span> <span class="quoted"><span class="quoted">"ℐ <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"fst <span class="keyword1">o</span> snd"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> bounded <span class="main">::</span> <span class="quoted"><span class="quoted">"ℐ <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"snd <span class="keyword1">o</span> snd"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ℐ <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mem</span> <span class="free"><span class="bound"><span class="entity">ℐ</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> memL <span class="free"><span class="bound"><span class="entity">ℐ</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">∧</span> memR <span class="free"><span class="bound"><span class="entity">ℐ</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> memL_mono<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"memL <span class="free">I</span> <span class="free">l</span> <span class="main">⟹</span> <span class="free">l</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> memL <span class="free">I</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upclosed_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> memR_antimono<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"memR <span class="free">I</span> <span class="free">r</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">r</span> <span class="main">⟹</span> memR <span class="free">I</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> downclosed_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> memR_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"memR <span class="free">I</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> downclosed_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> memR_nonzeroD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> memR <span class="free">I</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> contrapos_np<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> bounded_memR<span class="main">:</span> <span class="quoted"><span class="quoted">"bounded <span class="free">I</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m</span><span class="main">.</span> <span class="main">¬</span> memR <span class="free">I</span> <span class="bound">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lift_definition</span></span> all <span class="main">::</span> <span class="quoted">ℐ</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">,</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">,</span> False<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upclosed_def downclosed_def<span class="main">)</span>
<span class="keyword1"><span class="command">lift_definition</span></span> point <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> ℐ"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="main">(≤)</span> <span class="bound">n</span><span class="main">,</span> <span class="main">(≥)</span> <span class="bound">n</span><span class="main">,</span> True<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upclosed_def downclosed_def not_le<span class="main">)</span>
<span class="keyword1"><span class="command">lift_definition</span></span> subtract <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> ℐ <span class="main">⇒</span> ℐ"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">n</span> <span class="main">(</span><span class="bound">memL</span><span class="main">,</span> <span class="bound">memR</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">memL</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="bound">n</span><span class="main">)</span><span class="main">,</span> <span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="bound">memR</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="bound">n</span><span class="main">)</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upclosed_def downclosed_def<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> add.commute le_iff_add linear<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> le0 linorder_neqE_nat nat_le_iff_add not_less0<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> point_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"memL <span class="main">(</span>point <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(≤)</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"memR <span class="main">(</span>point <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(≥)</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"bounded <span class="main">(</span>point <span class="free">n</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> subtract_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"subtract <span class="main">0</span> <span class="free">I</span> <span class="main">=</span> <span class="free">I</span>"</span></span>
  <span class="quoted"><span class="quoted">"subtract <span class="free">x</span> <span class="main">(</span>point <span class="free">y</span><span class="main">)</span> <span class="main">=</span> point <span class="main">(</span><span class="free">y</span> <span class="main">-</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"memL <span class="main">(</span>subtract <span class="free">x</span> <span class="free">I</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> memL <span class="free">I</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"memR <span class="main">(</span>subtract <span class="free">x</span> <span class="free">I</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> memR <span class="free">I</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"bounded <span class="main">(</span>subtract <span class="free">x</span> <span class="free">I</span><span class="main">)</span> <span class="main">=</span> bounded <span class="free">I</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> downclosed_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> interval <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> enat <span class="main">⇒</span> ℐ"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l</span><span class="main">.</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> enat <span class="bound">l</span> <span class="main">≤</span> <span class="bound">r</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">l</span> <span class="main">≤</span> <span class="bound">i</span><span class="main">,</span> <span class="main">λ</span><span class="bound">i</span><span class="main">.</span> enat <span class="bound">i</span> <span class="main">≤</span> <span class="bound">r</span><span class="main">,</span> <span class="bound">r</span> <span class="main">≠</span> <span class="main">∞</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">,</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">,</span> False<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> enat_iless
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> upclosed_def downclosed_def not_le order_subst2<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span></pre>
</body>

</html>