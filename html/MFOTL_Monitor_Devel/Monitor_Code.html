<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Monitor_Code</title>
</head>


<body>
<div class="head">
<h1>Theory Monitor_Code</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Monitor_Code
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Monitor.html">Monitor</a>
    <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Nat.html">HOL-Library.Code_Target_Nat</a>"</span>
    <span class="quoted">"<a href="../../HOL/HOL/String.html">HOL.String</a>"</span>
    <a href="../Containers/Containers.html">Containers.Containers</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">derive</span></span> ccompare <span class="quoted">MFOTL.trm</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">MFOTL.trm</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>rbt<span class="main">)</span> set_impl <span class="quoted">MFOTL.trm</span>

<span class="keyword1"><span class="command">lemma</span></span> image_these<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> Option.these <span class="free">X</span> <span class="main">=</span> Option.these <span class="main">(</span>map_option <span class="free">f</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_these_eq Bex_def image_iff map_option_case <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> meval_MPred<span class="main">:</span> <span class="quoted"><span class="quoted">"meval <span class="free">n</span> <span class="free">t</span> <span class="free">db</span> <span class="main">(</span>MPred <span class="free">e</span> <span class="free">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span>Option.these
  <span class="main">(</span><span class="main">(</span>map_option <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> tabulate <span class="bound">f</span> <span class="main">0</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">o</span> match <span class="free">ts</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">e'</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">db</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">e</span> <span class="main">=</span> <span class="bound">e'</span> <span class="keyword1">then</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> MPred <span class="free">e</span> <span class="free">ts</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> meval.simps image_these image_image o_def <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> meval_MPred'<span class="main">:</span> <span class="quoted"><span class="quoted">"meval <span class="free">n</span> <span class="free">t</span> <span class="free">db</span> <span class="main">(</span>MPred <span class="free">e</span> <span class="free">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span>Option.these
  <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">e'</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">db</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">e</span> <span class="main">=</span> <span class="bound">e'</span> <span class="keyword1">then</span> <span class="main">{</span>map_option <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> tabulate <span class="bound">f</span> <span class="main">0</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>match <span class="free">ts</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> MPred <span class="free">e</span> <span class="free">ts</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> meval_MPred image_UN split_beta if_distrib<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"image <span class="main">_</span>"</span></span><span class="main">]</span> image_insert image_empty o_apply
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemma</span></span> these_UNION<span class="main">:</span> <span class="quoted"><span class="quoted">"Option.these <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="free">B</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span> <span class="main">(</span><span class="main">(</span>Option.these <span class="keyword1">o</span> <span class="free">B</span><span class="main">)</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Option.these_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> meval_MPred''<span class="main">:</span> <span class="quoted"><span class="quoted">"meval <span class="free">n</span> <span class="free">t</span> <span class="free">db</span> <span class="main">(</span>MPred <span class="free">e</span> <span class="free">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span>
  <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">e'</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">db</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">e</span> <span class="main">=</span> <span class="bound">e'</span> <span class="keyword1">then</span> set_option <span class="main">(</span>map_option <span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> tabulate <span class="bound">f</span> <span class="main">0</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>match <span class="free">ts</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> MPred <span class="free">e</span> <span class="free">ts</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> meval_MPred' these_UNION o_def prod.case_distrib<span class="main">[</span><span class="operator">of</span> <span class="quoted">Option.these</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Option.these_def map_option_case image_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> meval_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> meval.simps<span class="main">(</span>1<span class="main">)</span> meval_MPred'' meval.simps<span class="main">(</span>3-9<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">db_code</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>char list <span class="main">×</span> <span class="tfree">'a</span> list<span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span>char list <span class="main">×</span> <span class="tfree">'a</span> list<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">db_code</span> <span class="main">=</span> set"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">verdict_code</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'a</span> <span class="main">::</span> ccompare option list<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">verdict_code</span> <span class="main">=</span> RBT_Set2.keys"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">HOL.equal</span></span> <span class="quoted"><span class="quoted">Collection_Eq.ceq</span></span> <span class="quoted"><span class="quoted">Collection_Order.ccompare</span></span> <span class="quoted"><span class="quoted">Eq</span></span> <span class="quoted"><span class="quoted">Lt</span></span> <span class="quoted"><span class="quoted">Gt</span></span> <span class="quoted"><span class="quoted">set_RBT</span></span> <span class="quoted"><span class="quoted">set_impl</span></span> <span class="quoted"><span class="quoted">phantom</span></span>
  <span class="quoted"><span class="quoted">nat_of_integer</span></span> <span class="quoted"><span class="quoted">integer_of_nat</span></span> <span class="quoted"><span class="quoted">enat</span></span> <span class="quoted"><span class="quoted">literal.explode</span></span> <span class="quoted"><span class="quoted">db_code</span></span> <span class="quoted"><span class="quoted">set</span></span> <span class="quoted"><span class="quoted">interval</span></span> <span class="quoted"><span class="quoted">RBT_set</span></span> <span class="quoted"><span class="quoted">verdict_code</span></span>
  <span class="quoted"><span class="quoted">MFOTL.Var</span></span> <span class="quoted"><span class="quoted">MFOTL.Const</span></span>
  <span class="quoted"><span class="quoted">MFOTL.Pred</span></span> <span class="quoted"><span class="quoted">MFOTL.Eq</span></span> <span class="quoted"><span class="quoted">MFOTL.Neg</span></span> <span class="quoted"><span class="quoted">MFOTL.Or</span></span> <span class="quoted"><span class="quoted">MFOTL.Exists</span></span>
  <span class="quoted"><span class="quoted">MFOTL.Prev</span></span> <span class="quoted"><span class="quoted">MFOTL.Next</span></span> <span class="quoted"><span class="quoted">MFOTL.Since</span></span> <span class="quoted"><span class="quoted">MFOTL.Until</span></span>
  <span class="keyword2"><span class="keyword">checking</span></span> OCaml<span class="main">?</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">HOL.equal</span></span> <span class="quoted"><span class="quoted">Collection_Eq.ceq</span></span> <span class="quoted"><span class="quoted">Collection_Order.ccompare</span></span> <span class="quoted"><span class="quoted">Eq</span></span> <span class="quoted"><span class="quoted">Lt</span></span> <span class="quoted"><span class="quoted">Gt</span></span> <span class="quoted"><span class="quoted">set_RBT</span></span> <span class="quoted"><span class="quoted">set_impl</span></span> <span class="quoted"><span class="quoted">phantom</span></span>
  <span class="quoted"><span class="quoted">nat_of_integer</span></span> <span class="quoted"><span class="quoted">integer_of_nat</span></span> <span class="quoted"><span class="quoted">enat</span></span> <span class="quoted"><span class="quoted">literal.explode</span></span> <span class="quoted"><span class="quoted">db_code</span></span> <span class="quoted"><span class="quoted">set</span></span> <span class="quoted"><span class="quoted">interval</span></span> <span class="quoted"><span class="quoted">RBT_set</span></span> <span class="quoted"><span class="quoted">verdict_code</span></span>
  <span class="quoted"><span class="quoted">MFOTL.Var</span></span> <span class="quoted"><span class="quoted">MFOTL.Const</span></span>
  <span class="quoted"><span class="quoted">MFOTL.Pred</span></span> <span class="quoted"><span class="quoted">MFOTL.Eq</span></span> <span class="quoted"><span class="quoted">MFOTL.Neg</span></span> <span class="quoted"><span class="quoted">MFOTL.Or</span></span> <span class="quoted"><span class="quoted">MFOTL.Exists</span></span>
  <span class="quoted"><span class="quoted">MFOTL.Prev</span></span> <span class="quoted"><span class="quoted">MFOTL.Next</span></span> <span class="quoted"><span class="quoted">MFOTL.Since</span></span> <span class="quoted"><span class="quoted">MFOTL.Until</span></span>
  <span class="quoted"><span class="quoted">minit_safe</span></span> <span class="quoted"><span class="quoted">mstep</span></span> <span class="keyword2"><span class="keyword">in</span></span> OCaml <span class="keyword2"><span class="keyword">module_name</span></span> Monitor <span class="keyword2"><span class="keyword">file_prefix</span></span> <span class="quoted">"verified"</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</body>

</html>