<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Abstract_Monitor</title>
</head>


<body>
<div class="head">
<h1>Theory Abstract_Monitor</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Abstract_Monitor
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Trace.html">Trace</a> <a href="Table.html">Table</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstract monitors and slicing›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹First-order specifications›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We abstract from first-order trace specifications by referring only to their
  semantics. A first-order specification is described by a finite set of free
  variables and a satisfaction function that defines for every trace the pairs
  of valuations and time-points for which the specification is satisfied.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> fo_spec <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span>
    <span class="free">nfv</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    fv_less_nfv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">fv</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">nfv</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    sat_fv_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">fv</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">!</span><span class="bound">x</span> <span class="main">=</span> <span class="free">v'</span><span class="main">!</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">sat</span> <span class="free">σ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">=</span> <span class="free">sat</span> <span class="free">σ</span> <span class="free">v'</span> <span class="free">i</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">verdicts</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">verdicts</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free">sat</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">(</span>map the <span class="bound">v</span><span class="main">)</span> <span class="bound">i</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We usually employ a monitor to find the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹violations›</span></span> of a specification.
  That is, the monitor should output the satisfactions of its negation.
  Moreover, all monitor implementations must work with finite prefixes.
  We are therefore interested in co-safety properties, which allow us to
  identify all satisfactions on finite prefixes.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> cosafety_fo_spec <span class="main">=</span> fo_spec <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cosafety_lr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">σ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ'</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="bound">σ'</span> <span class="main">⟶</span> <span class="free">sat</span> <span class="bound">σ'</span> <span class="free">v</span> <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cosafety<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">σ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ'</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="bound">σ'</span> <span class="main">⟶</span> <span class="free">sat</span> <span class="bound">σ'</span> <span class="free">v</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> cosafety_lr <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monitor function›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We model monitors abstractly as functions from prefixes to verdict sets.
  The following locale specifies a minimal set of properties that any
  reasonable monitor should have.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> monitor <span class="main">=</span> fo_spec <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    mono_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="main">≤</span> <span class="free">π'</span> <span class="main">⟹</span> <span class="free">M</span> <span class="free">π</span> <span class="main">⊆</span> <span class="free">M</span> <span class="free">π'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    wf_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="free">π</span> <span class="main">⟹</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    sound_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="free">π</span> <span class="main">⟹</span> prefix_of <span class="free">π</span> <span class="free">σ</span> <span class="main">⟹</span> <span class="free">sat</span> <span class="free">σ</span> <span class="main">(</span>map the <span class="free">v</span><span class="main">)</span> <span class="free">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    complete_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="free">π</span> <span class="free">σ</span> <span class="main">⟹</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="free">v</span> <span class="main">⟹</span>
      <span class="main">(</span><span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> prefix_of <span class="free">π</span> <span class="bound">σ</span> <span class="main">⟹</span> <span class="free">sat</span> <span class="bound">σ</span> <span class="main">(</span>map the <span class="free">v</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">π'</span><span class="main">.</span> prefix_of <span class="bound">π'</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="bound">π'</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A monitor for a co-safety specification computes precisely the set of all
  satisfactions in the limit:
›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> monitor<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">M_limit</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="main">⋃</span><span class="main">{</span><span class="free">M</span> <span class="bound">π</span> <span class="main">|</span> <span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> cosafety_monitor <span class="main">=</span> cosafety_fo_spec <span class="main">+</span> monitor
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> M_limit_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"M_limit <span class="free">σ</span> <span class="main">=</span> verdicts <span class="free">σ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">{</span><span class="free">M</span> <span class="bound">π</span> <span class="main">|</span> <span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="free">σ</span><span class="main">}</span> <span class="main">⊆</span> verdicts <span class="free">σ</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> verdicts_def wf_monitor sound_monitor<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">{</span><span class="free">M</span> <span class="bound">π</span> <span class="main">|</span> <span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="free">σ</span><span class="main">}</span> <span class="main">⊇</span> verdicts <span class="free">σ</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> verdicts_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">σ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">π</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">π</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ'</span><span class="main">.</span> prefix_of <span class="skolem">π</span> <span class="bound">σ'</span> <span class="main">⟶</span> <span class="free">sat</span> <span class="bound">σ'</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cosafety_lr <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">π'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">π'</span> <span class="free">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="skolem">π'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> complete_monitor <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">{</span><span class="free">M</span> <span class="bound">π</span> <span class="main">|</span> <span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="free">σ</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The monitor function <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">M</span></span>›</span></span></span></span> adds some information over <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">sat</span></span>›</span></span></span></span>, namely
  when a verdict is output. One possible behavior is that the monitor outputs
  its verdicts for one time-point at a time, in increasing order of
  time-points. Then <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">M</span></span>›</span></span></span></span> is uniquely defined by a progress function, which
  returns for every prefix the time-point up to which all verdicts are computed.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> progress <span class="main">=</span> fo_spec _ _ <span class="quoted"><span class="free">sat</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">progress</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    progress_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="main">≤</span> <span class="free">π'</span> <span class="main">⟹</span> <span class="free">progress</span> <span class="free">π</span> <span class="main">≤</span> <span class="free">progress</span> <span class="free">π'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    ex_progress_ge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="free">σ</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">progress</span> <span class="bound">π</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    progress_sat_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="free">π</span> <span class="free">σ</span> <span class="main">⟹</span> prefix_of <span class="free">π</span> <span class="free">σ'</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="free">π</span> <span class="main">⟹</span>
      <span class="free">sat</span> <span class="free">σ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">⟷</span> <span class="free">sat</span> <span class="free">σ'</span> <span class="free">v</span> <span class="free">i</span>"</span></span>
    <span class="comment1">― ‹The last condition is not necessary to obtain a proper monitor function.
      However, it corresponds to the intuitive understanding of monitor progress,
      and it results in a stronger characterisation. In particular, it implies that
      the specification is co-safety, as we will show below.›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">∧</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="bound">v</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">σ</span><span class="main">.</span> prefix_of <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="bound">σ</span> <span class="main">⟶</span> <span class="free">sat</span> <span class="bound">σ</span> <span class="main">(</span>map the <span class="bound">v</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> M_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"M <span class="free">π</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="free">π</span> <span class="main">∧</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="bound">v</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∃</span><span class="bound">σ</span><span class="main">.</span> prefix_of <span class="free">π</span> <span class="bound">σ</span> <span class="main">∧</span> <span class="free">sat</span> <span class="bound">σ</span> <span class="main">(</span>map the <span class="bound">v</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ex_prefix_of<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">π</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> progress_sat_cong<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> progress <span class="main">⊆</span> cosafety_monitor _ _ _ <span class="quoted">M</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">σ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="skolem">σ</span> <span class="skolem">v</span> <span class="skolem">i</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">π</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">π</span> <span class="skolem">σ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="skolem">π</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ex_progress_ge <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_Suc_le<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="skolem">σ'</span> <span class="skolem">v</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">π</span> <span class="skolem">σ'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ'</span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> progress_sat_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">π</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">σ'</span><span class="main">.</span> prefix_of <span class="bound">π</span> <span class="bound">σ'</span> <span class="main">⟶</span> <span class="free">sat</span> <span class="bound">σ'</span> <span class="skolem">v</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">π</span> <span class="skolem">π'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">π</span> <span class="main">≤</span> <span class="skolem">π'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"M <span class="skolem">π</span> <span class="main">⊆</span> M <span class="skolem">π'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> progress_mono prefix_of_antimono
        <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> order.strict_trans2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span> <span class="skolem">π</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">σ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> M <span class="skolem">π</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M_def<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">π</span> <span class="skolem">σ</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="skolem">σ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span> <span class="skolem">π</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">σ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">π</span> <span class="skolem">σ</span>"</span></span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ'</span><span class="main">.</span> prefix_of <span class="skolem">π</span> <span class="bound">σ'</span> <span class="main">⟹</span> <span class="free">sat</span> <span class="bound">σ'</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">π'</span><span class="main">.</span> prefix_of <span class="bound">π'</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> M <span class="bound">π'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="skolem">π</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">π'</span></span> <span class="keyword2"><span class="keyword">where</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">π'</span> <span class="skolem">σ</span> <span class="main">∧</span> <span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="skolem">π'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ex_progress_ge <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_Suc_le<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">π</span> <span class="main">≤</span> <span class="skolem">π'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹prefix_of <span class="skolem">π</span> <span class="skolem">σ</span>›</span></span> prefix_of_imp_linear False progress_mono
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order.strict_trans2<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> * ** <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> prefix_of_antimono<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Slicing›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Sliceable specifications can be evaluated meaningfully on a subset of events.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> abstract_slicer <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">relevant_events</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">slice</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">⇒</span> <span class="tfree">'a</span> trace <span class="main">⇒</span> <span class="tfree">'a</span> trace"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">slice</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> map_Γ <span class="main">(</span><span class="main">λ</span><span class="bound">D</span><span class="main">.</span> <span class="bound">D</span> <span class="main">∩</span> <span class="free">relevant_events</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">pslice</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">⇒</span> <span class="tfree">'a</span> prefix <span class="main">⇒</span> <span class="tfree">'a</span> prefix"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pslice</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> pmap_Γ <span class="main">(</span><span class="main">λ</span><span class="bound">D</span><span class="main">.</span> <span class="bound">D</span> <span class="main">∩</span> <span class="free">relevant_events</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prefix_of_psliceI<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="free">π</span> <span class="free">σ</span> <span class="main">⟹</span> prefix_of <span class="main">(</span>pslice <span class="free">S</span> <span class="free">π</span><span class="main">)</span> <span class="main">(</span>slice <span class="free">S</span> <span class="free">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> plen_pslice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plen <span class="main">(</span>pslice <span class="free">S</span> <span class="free">π</span><span class="main">)</span> <span class="main">=</span> plen <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> pslice_pnil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pslice <span class="free">S</span> pnil <span class="main">=</span> pnil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> last_ts_pslice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"last_ts <span class="main">(</span>pslice <span class="free">S</span> <span class="free">π</span><span class="main">)</span> <span class="main">=</span> last_ts <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_map case_prod_beta <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">verdict_filter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">verdict_filter</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound"><span class="bound">i</span></span><span class="main">,</span> <span class="bound"><span class="bound">v</span></span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">.</span> mem_restr <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">v</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> sliceable_fo_spec <span class="main">=</span> fo_spec _ _ <span class="quoted"><span class="free">sat</span></span> <span class="main">+</span> abstract_slicer <span class="quoted"><span class="free">relevant_events</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">relevant_events</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sliceable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟹</span> <span class="free">sat</span> <span class="main">(</span>slice <span class="free">S</span> <span class="free">σ</span><span class="main">)</span> <span class="free">v</span> <span class="free">i</span> <span class="main">⟷</span> <span class="free">sat</span> <span class="free">σ</span> <span class="free">v</span> <span class="free">i</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> union_verdicts_slice<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> part<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="free">𝒮</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span>verdicts <span class="main">(</span>slice <span class="bound">S</span> <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">𝒮</span><span class="main">)</span> <span class="main">=</span> verdicts <span class="free">σ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> verdicts <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> tuple<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">σ</span><span class="main">)</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">∈</span><span class="free">fv</span><span class="main">.</span> <span class="skolem">v</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">v'</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fv_less_nfv <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> mem_restrE<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">σ</span><span class="main">)</span> <span class="skolem">v'</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">σ</span><span class="main">)</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>›</span></span> tuple
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_length fv_less_nfv <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sat_fv_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">σ</span> <span class="skolem">v'</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sliceable<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">v'</span> <span class="main">∈</span> <span class="skolem">S</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">σ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple 1
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_length fv_less_nfv <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sat_fv_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> verdicts <span class="free">σ</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> verdicts <span class="free">σ</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> tuple<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">σ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> part <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">∈</span> <span class="free">𝒮</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mem_restrI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="quoted"><span class="free">nfv</span></span> <span class="quoted"><span class="free">fv</span></span><span class="main">]</span> tuple
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_def fv_less_nfv<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">σ</span><span class="main">)</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">sat</span> <span class="free">σ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>›</span></span> sliceable<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹map the <span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">S</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> verdicts <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">σ</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">S</span><span class="main">∈</span><span class="free">𝒮</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span>verdicts <span class="main">(</span>slice <span class="bound">S</span> <span class="free">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">S</span> <span class="main">∈</span> <span class="free">𝒮</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define a similar notion for monitors. It is potentially stronger because
  the time-point at which verdicts are output must not change.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> sliceable_monitor <span class="main">=</span> monitor _ _ <span class="quoted"><span class="free">sat</span></span> <span class="quoted"><span class="free">M</span></span> <span class="main">+</span> abstract_slicer <span class="quoted"><span class="free">relevant_events</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">relevant_events</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">⇒</span> <span class="tfree">'b</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sliceable_M<span class="main">:</span> <span class="quoted"><span class="quoted">"mem_restr <span class="free">S</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="main">(</span>pslice <span class="free">S</span> <span class="free">π</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="free">π</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> union_M_pslice<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> part<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="free">𝒮</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span><span class="free">M</span> <span class="main">(</span>pslice <span class="bound">S</span> <span class="free">π</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">𝒮</span><span class="main">)</span> <span class="main">=</span> <span class="free">M</span> <span class="free">π</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="main">(</span>pslice <span class="skolem">S</span> <span class="free">π</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="free">π</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> sliceable_M <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> tuple<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> wf_monitor<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> part <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">∈</span> <span class="free">𝒮</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span> <span class="main">∈</span> <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mem_restrI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="quoted"><span class="free">nfv</span></span> <span class="quoted"><span class="free">fv</span></span><span class="main">]</span> tuple
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_def fv_less_nfv<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="main">(</span>pslice <span class="skolem">S</span> <span class="free">π</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span> <span class="free">π</span>›</span></span> sliceable_M <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">S</span><span class="main">∈</span><span class="free">𝒮</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span><span class="free">M</span> <span class="main">(</span>pslice <span class="bound">S</span> <span class="free">π</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">S</span> <span class="main">∈</span> <span class="free">𝒮</span>›</span></span> <span class="quoted"><span class="quoted">‹mem_restr <span class="skolem">S</span> <span class="skolem">v</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  If the specification is sliceable and the monitor's progress depends only on
  time-stamps, then also the monitor itself is sliceable.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> timed_progress <span class="main">=</span> progress <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> progress_time_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"pts <span class="free">π</span> <span class="main">=</span> pts <span class="free">π'</span> <span class="main">⟹</span> <span class="free">progress</span> <span class="free">π</span> <span class="main">=</span> <span class="free">progress</span> <span class="free">π'</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> sliceable_timed_progress <span class="main">=</span> sliceable_fo_spec <span class="main">+</span> timed_progress
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> progress_pslice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">progress</span> <span class="main">(</span>pslice <span class="free">S</span> <span class="free">π</span><span class="main">)</span> <span class="main">=</span> <span class="free">progress</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> progress_time_conv<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> sliceable_timed_progress <span class="main">⊆</span> sliceable_monitor _ _ _ _ <span class="quoted">M</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="skolem">i</span> <span class="skolem">π</span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> M <span class="main">(</span>pslice <span class="skolem">S</span> <span class="skolem">π</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> M <span class="skolem">π</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">⟷</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 4 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def wf_tuple_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mem_restrE
          box_equals<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sliceable sat_fv_cong sat_fv_cong<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD1<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span>
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> prefix_of_psliceI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fv_less_nfv spec<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"slice <span class="skolem">S</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 4 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_alt wf_tuple_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mem_restrE
        box_equals<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sliceable sat_fv_cong sat_fv_cong<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD2<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"slice <span class="skolem">S</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> prefix_of_psliceI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fv_less_nfv<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</body>

</html>