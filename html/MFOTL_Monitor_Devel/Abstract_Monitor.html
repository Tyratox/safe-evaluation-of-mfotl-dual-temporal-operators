<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Abstract_Monitor</title>
</head>


<body>
<div class="head">
<h1>Theory Abstract_Monitor</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Abstract_Monitor
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Trace.html">Trace</a> <a href="Table.html">Table</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">â€¹Abstract monitors and slicingâ€º</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">â€¹First-order specificationsâ€º</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹
  We abstract from first-order trace specifications by referring only to their
  semantics. A first-order specification is described by a finite set of free
  variables and a satisfaction function that defines for every trace the pairs
  of valuations and time-points for which the specification is satisfied.
â€º</span></span>

<span class="keyword1"><span class="command">locale</span></span> fo_spec <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span>
    <span class="free">nfv</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">â‡’</span> <span class="tfree">'b</span> list <span class="main">â‡’</span> nat <span class="main">â‡’</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    fv_less_nfv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">âˆˆ</span> <span class="free">fv</span> <span class="main">âŸ¹</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">nfv</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    sat_fv_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">â‹€</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">âˆˆ</span> <span class="free">fv</span> <span class="main">âŸ¹</span> <span class="free">v</span><span class="main">!</span><span class="bound">x</span> <span class="main">=</span> <span class="free">v'</span><span class="main">!</span><span class="bound">x</span><span class="main">)</span> <span class="main">âŸ¹</span> <span class="free">sat</span> <span class="free">Ïƒ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">=</span> <span class="free">sat</span> <span class="free">Ïƒ</span> <span class="free">v'</span> <span class="free">i</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">verdicts</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">â‡’</span> <span class="main">(</span>nat <span class="main">Ã—</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">verdicts</span> <span class="free"><span class="bound"><span class="entity">Ïƒ</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="bound">v</span> <span class="main">âˆ§</span> <span class="free">sat</span> <span class="free"><span class="bound"><span class="entity">Ïƒ</span></span></span> <span class="main">(</span>map the <span class="bound">v</span><span class="main">)</span> <span class="bound">i</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹
  We usually employ a monitor to find the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">âˆ—</span></span>â€¹violationsâ€º</span></span> of a specification.
  That is, the monitor should output the satisfactions of its negation.
  Moreover, all monitor implementations must work with finite prefixes.
  We are therefore interested in co-safety properties, which allow us to
  identify all satisfactions on finite prefixes.
â€º</span></span>

<span class="keyword1"><span class="command">locale</span></span> cosafety_fo_spec <span class="main">=</span> fo_spec <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cosafety_lr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">Ïƒ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">âŸ¹</span> <span class="main">âˆƒ</span><span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âˆ§</span> <span class="main">(</span><span class="main">âˆ€</span><span class="bound">Ïƒ'</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="bound">Ïƒ'</span> <span class="main">âŸ¶</span> <span class="free">sat</span> <span class="bound">Ïƒ'</span> <span class="free">v</span> <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cosafety<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">Ïƒ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">âŸ·</span> <span class="main">(</span><span class="main">âˆƒ</span><span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âˆ§</span> <span class="main">(</span><span class="main">âˆ€</span><span class="bound">Ïƒ'</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="bound">Ïƒ'</span> <span class="main">âŸ¶</span> <span class="free">sat</span> <span class="bound">Ïƒ'</span> <span class="free">v</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> cosafety_lr <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">â€¹Monitor functionâ€º</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹
  We model monitors abstractly as functions from prefixes to verdict sets.
  The following locale specifies a minimal set of properties that any
  reasonable monitor should have.
â€º</span></span>

<span class="keyword1"><span class="command">locale</span></span> monitor <span class="main">=</span> fo_spec <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix <span class="main">â‡’</span> <span class="main">(</span>nat <span class="main">Ã—</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    mono_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Ï€</span> <span class="main">â‰¤</span> <span class="free">Ï€'</span> <span class="main">âŸ¹</span> <span class="free">M</span> <span class="free">Ï€</span> <span class="main">âŠ†</span> <span class="free">M</span> <span class="free">Ï€'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    wf_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="free">Ï€</span> <span class="main">âŸ¹</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    sound_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="free">Ï€</span> <span class="main">âŸ¹</span> prefix_of <span class="free">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âŸ¹</span> <span class="free">sat</span> <span class="free">Ïƒ</span> <span class="main">(</span>map the <span class="free">v</span><span class="main">)</span> <span class="free">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    complete_monitor<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="free">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âŸ¹</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="free">v</span> <span class="main">âŸ¹</span>
      <span class="main">(</span><span class="main">â‹€</span><span class="bound">Ïƒ</span><span class="main">.</span> prefix_of <span class="free">Ï€</span> <span class="bound">Ïƒ</span> <span class="main">âŸ¹</span> <span class="free">sat</span> <span class="bound">Ïƒ</span> <span class="main">(</span>map the <span class="free">v</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span> <span class="main">âŸ¹</span> <span class="main">âˆƒ</span><span class="bound">Ï€'</span><span class="main">.</span> prefix_of <span class="bound">Ï€'</span> <span class="free">Ïƒ</span> <span class="main">âˆ§</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="bound">Ï€'</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹
  A monitor for a co-safety specification computes precisely the set of all
  satisfactions in the limit:
â€º</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> monitor<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">M_limit</span> <span class="free"><span class="bound"><span class="entity">Ïƒ</span></span></span> <span class="main">â‰¡</span> <span class="main">â‹ƒ</span><span class="main">{</span><span class="free">M</span> <span class="bound">Ï€</span> <span class="main">|</span> <span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="free"><span class="bound"><span class="entity">Ïƒ</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> cosafety_monitor <span class="main">=</span> cosafety_fo_spec <span class="main">+</span> monitor
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> M_limit_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"M_limit <span class="free">Ïƒ</span> <span class="main">=</span> verdicts <span class="free">Ïƒ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">â‹ƒ</span><span class="main">{</span><span class="free">M</span> <span class="bound">Ï€</span> <span class="main">|</span> <span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="free">Ïƒ</span><span class="main">}</span> <span class="main">âŠ†</span> verdicts <span class="free">Ïƒ</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> verdicts_def wf_monitor sound_monitor<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">â‹ƒ</span><span class="main">{</span><span class="free">M</span> <span class="bound">Ï€</span> <span class="main">|</span> <span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="free">Ïƒ</span><span class="main">}</span> <span class="main">âŠ‡</span> verdicts <span class="free">Ïƒ</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> verdicts_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">Ïƒ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Ï€</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âˆ§</span> <span class="main">(</span><span class="main">âˆ€</span><span class="bound">Ïƒ'</span><span class="main">.</span> prefix_of <span class="skolem">Ï€</span> <span class="bound">Ïƒ'</span> <span class="main">âŸ¶</span> <span class="free">sat</span> <span class="bound">Ïƒ'</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cosafety_lr <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">â€¹wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>â€º</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Ï€'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">Ï€'</span> <span class="free">Ïƒ</span> <span class="main">âˆ§</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="skolem">Ï€'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> complete_monitor <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="main">â‹ƒ</span><span class="main">{</span><span class="free">M</span> <span class="bound">Ï€</span> <span class="main">|</span> <span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="free">Ïƒ</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹
  The monitor function <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">â€¹<span class="free"><span class="free">M</span></span>â€º</span></span></span></span> adds some information over <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">â€¹<span class="free"><span class="free">sat</span></span>â€º</span></span></span></span>, namely
  when a verdict is output. One possible behavior is that the monitor outputs
  its verdicts for one time-point at a time, in increasing order of
  time-points. Then <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">â€¹<span class="free"><span class="free">M</span></span>â€º</span></span></span></span> is uniquely defined by a progress function, which
  returns for every prefix the time-point up to which all verdicts are computed.
â€º</span></span>

<span class="keyword1"><span class="command">locale</span></span> progress <span class="main">=</span> fo_spec _ _ <span class="quoted"><span class="free">sat</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">â‡’</span> <span class="tfree">'b</span> list <span class="main">â‡’</span> nat <span class="main">â‡’</span> bool"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">progress</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix <span class="main">â‡’</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    progress_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Ï€</span> <span class="main">â‰¤</span> <span class="free">Ï€'</span> <span class="main">âŸ¹</span> <span class="free">progress</span> <span class="free">Ï€</span> <span class="main">â‰¤</span> <span class="free">progress</span> <span class="free">Ï€'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    ex_progress_ge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">âˆƒ</span><span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âˆ§</span> <span class="free">x</span> <span class="main">â‰¤</span> <span class="free">progress</span> <span class="bound">Ï€</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    progress_sat_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="free">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âŸ¹</span> prefix_of <span class="free">Ï€</span> <span class="free">Ïƒ'</span> <span class="main">âŸ¹</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="free">Ï€</span> <span class="main">âŸ¹</span>
      <span class="free">sat</span> <span class="free">Ïƒ</span> <span class="free">v</span> <span class="free">i</span> <span class="main">âŸ·</span> <span class="free">sat</span> <span class="free">Ïƒ'</span> <span class="free">v</span> <span class="free">i</span>"</span></span>
    <span class="comment1">â€• â€¹The last condition is not necessary to obtain a proper monitor function.
      However, it corresponds to the intuitive understanding of monitor progress,
      and it results in a stronger characterisation. In particular, it implies that
      the specification is co-safety, as we will show below.â€º</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix <span class="main">â‡’</span> <span class="main">(</span>nat <span class="main">Ã—</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="free"><span class="bound"><span class="entity">Ï€</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="free"><span class="bound"><span class="entity">Ï€</span></span></span> <span class="main">âˆ§</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="bound">v</span> <span class="main">âˆ§</span>
    <span class="main">(</span><span class="main">âˆ€</span><span class="bound">Ïƒ</span><span class="main">.</span> prefix_of <span class="free"><span class="bound"><span class="entity">Ï€</span></span></span> <span class="bound">Ïƒ</span> <span class="main">âŸ¶</span> <span class="free">sat</span> <span class="bound">Ïƒ</span> <span class="main">(</span>map the <span class="bound">v</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> M_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"M <span class="free">Ï€</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="free">Ï€</span> <span class="main">âˆ§</span> wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="bound">v</span> <span class="main">âˆ§</span>
    <span class="main">(</span><span class="main">âˆƒ</span><span class="bound">Ïƒ</span><span class="main">.</span> prefix_of <span class="free">Ï€</span> <span class="bound">Ïƒ</span> <span class="main">âˆ§</span> <span class="free">sat</span> <span class="bound">Ïƒ</span> <span class="main">(</span>map the <span class="bound">v</span><span class="main">)</span> <span class="bound">i</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ex_prefix_of<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">Ï€</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> progress_sat_cong<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> progress <span class="main">âŠ†</span> cosafety_monitor _ _ _ <span class="quoted">M</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">Ïƒ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="skolem">Ïƒ</span> <span class="skolem">v</span> <span class="skolem">i</span>"</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Ï€</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">Ï€</span> <span class="skolem">Ïƒ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="skolem">Ï€</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ex_progress_ge <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_Suc_le<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="skolem">Ïƒ'</span> <span class="skolem">v</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">Ï€</span> <span class="skolem">Ïƒ'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">Ïƒ'</span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> progress_sat_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">âˆƒ</span><span class="bound">Ï€</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="skolem">Ïƒ</span> <span class="main">âˆ§</span> <span class="main">(</span><span class="main">âˆ€</span><span class="bound">Ïƒ'</span><span class="main">.</span> prefix_of <span class="bound">Ï€</span> <span class="bound">Ïƒ'</span> <span class="main">âŸ¶</span> <span class="free">sat</span> <span class="bound">Ïƒ'</span> <span class="skolem">v</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Ï€</span> <span class="skolem">Ï€'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prefix"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Ï€</span> <span class="main">â‰¤</span> <span class="skolem">Ï€'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"M <span class="skolem">Ï€</span> <span class="main">âŠ†</span> M <span class="skolem">Ï€'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> progress_mono prefix_of_antimono
        <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> order.strict_trans2<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span> <span class="skolem">Ï€</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">Ïƒ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> M <span class="skolem">Ï€</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M_def<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">Ï€</span> <span class="skolem">Ïƒ</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="skolem">Ïƒ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">v</span> <span class="skolem">Ï€</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">Ïƒ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">Ï€</span> <span class="skolem">Ïƒ</span>"</span></span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">â‹€</span><span class="bound">Ïƒ'</span><span class="main">.</span> prefix_of <span class="skolem">Ï€</span> <span class="bound">Ïƒ'</span> <span class="main">âŸ¹</span> <span class="free">sat</span> <span class="bound">Ïƒ'</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">âˆƒ</span><span class="bound">Ï€'</span><span class="main">.</span> prefix_of <span class="bound">Ï€'</span> <span class="skolem">Ïƒ</span> <span class="main">âˆ§</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> M <span class="bound">Ï€'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="skolem">Ï€</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Ï€'</span></span> <span class="keyword2"><span class="keyword">where</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="skolem">Ï€'</span> <span class="skolem">Ïƒ</span> <span class="main">âˆ§</span> <span class="skolem">i</span> <span class="main">&lt;</span> <span class="free">progress</span> <span class="skolem">Ï€'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ex_progress_ge <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_eq_Suc_le<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Ï€</span> <span class="main">â‰¤</span> <span class="skolem">Ï€'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">â€¹prefix_of <span class="skolem">Ï€</span> <span class="skolem">Ïƒ</span>â€º</span></span> prefix_of_imp_linear False progress_mono
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> order.strict_trans2<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> * ** <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> prefix_of_antimono<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">â€¹Slicingâ€º</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹Sliceable specifications can be evaluated meaningfully on a subset of events.â€º</span></span>

<span class="keyword1"><span class="command">locale</span></span> abstract_slicer <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">relevant_events</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">â‡’</span> <span class="tfree">'a</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">slice</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">â‡’</span> <span class="tfree">'a</span> trace <span class="main">â‡’</span> <span class="tfree">'a</span> trace"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">slice</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">â‰¡</span> map_Î“ <span class="main">(</span><span class="main">Î»</span><span class="bound">D</span><span class="main">.</span> <span class="bound">D</span> <span class="main">âˆ©</span> <span class="free">relevant_events</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">pslice</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">â‡’</span> <span class="tfree">'a</span> prefix <span class="main">â‡’</span> <span class="tfree">'a</span> prefix"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pslice</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">â‰¡</span> pmap_Î“ <span class="main">(</span><span class="main">Î»</span><span class="bound">D</span><span class="main">.</span> <span class="bound">D</span> <span class="main">âˆ©</span> <span class="free">relevant_events</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prefix_of_psliceI<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix_of <span class="free">Ï€</span> <span class="free">Ïƒ</span> <span class="main">âŸ¹</span> prefix_of <span class="main">(</span>pslice <span class="free">S</span> <span class="free">Ï€</span><span class="main">)</span> <span class="main">(</span>slice <span class="free">S</span> <span class="free">Ïƒ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> plen_pslice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plen <span class="main">(</span>pslice <span class="free">S</span> <span class="free">Ï€</span><span class="main">)</span> <span class="main">=</span> plen <span class="free">Ï€</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> pslice_pnil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pslice <span class="free">S</span> pnil <span class="main">=</span> pnil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> last_ts_pslice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"last_ts <span class="main">(</span>pslice <span class="free">S</span> <span class="free">Ï€</span><span class="main">)</span> <span class="main">=</span> last_ts <span class="free">Ï€</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">S</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_map case_prod_beta <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> list.split<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">verdict_filter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">â‡’</span> <span class="main">(</span>nat <span class="main">Ã—</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set <span class="main">â‡’</span> <span class="main">(</span>nat <span class="main">Ã—</span> <span class="tfree">'b</span> tuple<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">verdict_filter</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">â‰¡</span> <span class="main">{</span><span class="main">(</span><span class="bound"><span class="bound">i</span></span><span class="main">,</span> <span class="bound"><span class="bound">v</span></span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">.</span> mem_restr <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="bound">v</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> sliceable_fo_spec <span class="main">=</span> fo_spec _ _ <span class="quoted"><span class="free">sat</span></span> <span class="main">+</span> abstract_slicer <span class="quoted"><span class="free">relevant_events</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">relevant_events</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">â‡’</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">â‡’</span> <span class="tfree">'b</span> list <span class="main">â‡’</span> nat <span class="main">â‡’</span> bool"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sliceable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">âˆˆ</span> <span class="free">S</span> <span class="main">âŸ¹</span> <span class="free">sat</span> <span class="main">(</span>slice <span class="free">S</span> <span class="free">Ïƒ</span><span class="main">)</span> <span class="free">v</span> <span class="free">i</span> <span class="main">âŸ·</span> <span class="free">sat</span> <span class="free">Ïƒ</span> <span class="free">v</span> <span class="free">i</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> union_verdicts_slice<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> part<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">â‹ƒ</span><span class="free">ğ’®</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">â‹ƒ</span><span class="main">(</span><span class="main">(</span><span class="main">Î»</span><span class="bound">S</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span>verdicts <span class="main">(</span>slice <span class="bound">S</span> <span class="free">Ïƒ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">ğ’®</span><span class="main">)</span> <span class="main">=</span> verdicts <span class="free">Ïƒ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> verdicts <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">Ïƒ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> tuple<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">Ïƒ</span><span class="main">)</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">âˆˆ</span> <span class="skolem">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">âˆ€</span><span class="bound">i</span><span class="main">âˆˆ</span><span class="free">fv</span><span class="main">.</span> <span class="skolem">v</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">v'</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fv_less_nfv <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> mem_restrE<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">Ïƒ</span><span class="main">)</span> <span class="skolem">v'</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">â€¹<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">Ïƒ</span><span class="main">)</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>â€º</span></span> tuple
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_length fv_less_nfv <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sat_fv_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">Ïƒ</span> <span class="skolem">v'</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sliceable<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">â€¹<span class="skolem">v'</span> <span class="main">âˆˆ</span> <span class="skolem">S</span>â€º</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">Ïƒ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple 1
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_length fv_less_nfv <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sat_fv_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> verdicts <span class="free">Ïƒ</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> verdicts <span class="free">Ïƒ</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> tuple<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="free">Ïƒ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> part <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">âˆˆ</span> <span class="free">ğ’®</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span> <span class="main">âˆˆ</span> <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mem_restrI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="quoted"><span class="free">nfv</span></span> <span class="quoted"><span class="free">fv</span></span><span class="main">]</span> tuple
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_def fv_less_nfv<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sat</span> <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">Ïƒ</span><span class="main">)</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">â€¹<span class="free">sat</span> <span class="free">Ïƒ</span> <span class="main">(</span>map the <span class="skolem">v</span><span class="main">)</span> <span class="skolem">i</span>â€º</span></span> sliceable<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">â€¹map the <span class="skolem">v</span> <span class="main">âˆˆ</span> <span class="skolem">S</span>â€º</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> verdicts <span class="main">(</span>slice <span class="skolem">S</span> <span class="free">Ïƒ</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> tuple <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> verdicts_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="main">(</span><span class="main">â‹ƒ</span><span class="bound">S</span><span class="main">âˆˆ</span><span class="free">ğ’®</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span>verdicts <span class="main">(</span>slice <span class="bound">S</span> <span class="free">Ïƒ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">â€¹<span class="skolem">S</span> <span class="main">âˆˆ</span> <span class="free">ğ’®</span>â€º</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹
  We define a similar notion for monitors. It is potentially stronger because
  the time-point at which verdicts are output must not change.
â€º</span></span>

<span class="keyword1"><span class="command">locale</span></span> sliceable_monitor <span class="main">=</span> monitor _ _ <span class="quoted"><span class="free">sat</span></span> <span class="quoted"><span class="free">M</span></span> <span class="main">+</span> abstract_slicer <span class="quoted"><span class="free">relevant_events</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">relevant_events</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list set <span class="main">â‡’</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> trace <span class="main">â‡’</span> <span class="tfree">'b</span> list <span class="main">â‡’</span> nat <span class="main">â‡’</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sliceable_M<span class="main">:</span> <span class="quoted"><span class="quoted">"mem_restr <span class="free">S</span> <span class="free">v</span> <span class="main">âŸ¹</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="main">(</span>pslice <span class="free">S</span> <span class="free">Ï€</span><span class="main">)</span> <span class="main">âŸ·</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="free">Ï€</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> union_M_pslice<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> part<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">â‹ƒ</span><span class="free">ğ’®</span> <span class="main">=</span> UNIV"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">â‹ƒ</span><span class="main">(</span><span class="main">(</span><span class="main">Î»</span><span class="bound">S</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span><span class="free">M</span> <span class="main">(</span>pslice <span class="bound">S</span> <span class="free">Ï€</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">ğ’®</span><span class="main">)</span> <span class="main">=</span> <span class="free">M</span> <span class="free">Ï€</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="main">(</span>pslice <span class="skolem">S</span> <span class="free">Ï€</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="free">Ï€</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> sliceable_M <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> tuple"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="free">Ï€</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> tuple<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_tuple <span class="free">nfv</span> <span class="free">fv</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> wf_monitor<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> part <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">âˆˆ</span> <span class="free">ğ’®</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span> <span class="main">âˆˆ</span> <span class="skolem">S</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mem_restrI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"map the <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="quoted"><span class="free">nfv</span></span> <span class="quoted"><span class="free">fv</span></span><span class="main">]</span> tuple
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_tuple_def fv_less_nfv<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="main">(</span>pslice <span class="skolem">S</span> <span class="free">Ï€</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">â€¹<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="free">M</span> <span class="free">Ï€</span>â€º</span></span> sliceable_M <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> <span class="main">(</span><span class="main">â‹ƒ</span><span class="bound">S</span><span class="main">âˆˆ</span><span class="free">ğ’®</span><span class="main">.</span> verdict_filter <span class="bound">S</span> <span class="main">(</span><span class="free">M</span> <span class="main">(</span>pslice <span class="bound">S</span> <span class="free">Ï€</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">â€¹<span class="skolem">S</span> <span class="main">âˆˆ</span> <span class="free">ğ’®</span>â€º</span></span> <span class="quoted"><span class="quoted">â€¹mem_restr <span class="skolem">S</span> <span class="skolem">v</span>â€º</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">â€¹
  If the specification is sliceable and the monitor's progress depends only on
  time-stamps, then also the monitor itself is sliceable.
â€º</span></span>

<span class="keyword1"><span class="command">locale</span></span> timed_progress <span class="main">=</span> progress <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> progress_time_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"pts <span class="free">Ï€</span> <span class="main">=</span> pts <span class="free">Ï€'</span> <span class="main">âŸ¹</span> <span class="free">progress</span> <span class="free">Ï€</span> <span class="main">=</span> <span class="free">progress</span> <span class="free">Ï€'</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> sliceable_timed_progress <span class="main">=</span> sliceable_fo_spec <span class="main">+</span> timed_progress
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> progress_pslice<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">progress</span> <span class="main">(</span>pslice <span class="free">S</span> <span class="free">Ï€</span><span class="main">)</span> <span class="main">=</span> <span class="free">progress</span> <span class="free">Ï€</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> progress_time_conv<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> sliceable_timed_progress <span class="main">âŠ†</span> sliceable_monitor _ _ _ _ <span class="quoted">M</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">v</span> <span class="skolem">i</span> <span class="skolem">Ï€</span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"mem_restr <span class="skolem">S</span> <span class="skolem">v</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> M <span class="main">(</span>pslice <span class="skolem">S</span> <span class="skolem">Ï€</span><span class="main">)</span> <span class="main">âŸ·</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">âˆˆ</span> M <span class="skolem">Ï€</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span> <span class="main">âŸ·</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 4 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_def wf_tuple_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mem_restrE
          box_equals<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sliceable sat_fv_cong sat_fv_cong<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD1<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span>
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> prefix_of_psliceI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fv_less_nfv spec<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"slice <span class="skolem">S</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?L</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 4 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M_alt wf_tuple_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mem_restrE
        box_equals<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sliceable sat_fv_cong sat_fv_cong<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> iffD2<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"slice <span class="skolem">S</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> prefix_of_psliceI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fv_less_nfv<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</body>

</html>